# L-EDGE-Liminal-Edge-OS — архитектурный рефакторинг (бриф)

## Зоны внимания

- **Слоевой организм:** нужен единый манифест слоёв (ID, имя, роль, зависимости, входы/выходы) в JSON/YAML/TOON + TS-типизация.
- **Три оси развития:** личная, возрастная, социально-космическая оси должны быть оформлены как core-модуль с единым типом состояния и функциями синхронизации.
- **Действующие силы:** оформить 24 силы + Инь/Ян/Инь=Ян/ТАО как рабочий модуль с состоянием, API для активации/приглушения и тестами.
- **Петли времени:** собрать прошлое/настоящее/будущее в core/timeLoops с типами TemporalState/Loop/Observer и утилитами для дрейфа и траекторий.
- **Документация слоёв:** выровнять описания L0–L30, добавить минимальные примеры и базовые тесты, где применимо.
- **Структура проекта:** фундаментальные сущности в `core/`, реализации слоёв в `layers/`, примеры в `examples/`, тесты зеркалят структуру.

## Задание для Codex

> Проведи глубокий архитектурный рефакторинг репозитория L-EDGE-Liminal-Edge-OS перед движением к L31+. Не придумывай новые идеи — зафиксируй существующие. Цель: сделать слои единым организмом, отражающим концепцию.
>
> ### Этап 1 — манифест слоёв
> 1. Собери список слоёв (L0–L30 и вспомогательные).
> 2. Создай файл манифеста, например `core/layers.manifest.ts` или `layers/layers.manifest.ts`, при необходимости дополни `.json/.toon`.
> 3. Для каждого слоя укажи: `id`, `name`, `description`, `category`, `dependencies`.
> 4. Добавь TypeScript-типизацию для манифеста.
>
> ### Этап 2 — три оси развития
> 1. Создай модуль `core/orientationAxes/`.
> 2. Определи типы `PersonalAxisState`, `AgeAxisState`, `SocialCosmicAxisState` и агрегирующий `OrientationAxesState`.
> 3. Вынеси связанные данные из слоёв в этот модуль и используй его по всему коду.
>
> ### Этап 3 — действующие силы
> 1. Создай модуль `core/dynamicForces/` с перечислением 24 сил.
> 2. Определи состояния сил (`ForceLevel`), полярности (`PolarityState`: Инь, Ян, Инь=Ян) и `TaoBalance`.
> 3. Реализуй функции `computePolarity`, `computeTaoBalance`, утилиты плавного обновления.
> 4. Покрой модуль тестами на устойчивость расчётов.
>
> ### Этап 4 — петли времени
> 1. Создай модуль `core/timeLoops/` с типами `TemporalSnapshot`, `TemporalLoop`, `TemporalDrift` и интерфейсом `TemporalObserver`.
> 2. Реализуй функции сравнения прошлого/настоящего/будущего, расчёта дрейфа и оценки траектории; добавь минимальные тесты.
>
> ### Этап 5 — структурный рефакторинг
> 1. Разнеси фундаментальные сущности в `core/`, слои в `layers/`, примеры в `examples/`, тесты зеркалят структуру.
> 2. Обнови слои, использующие оси/время/силы, чтобы они опирались на новые core-модули без ломки публичного API (при необходимости — через deprecation).
>
> ### Этап 6 — документация и примеры
> 1. Обнови описания L0–L30, добавь краткие примеры использования.
> 2. В корневом README или `docs/layers-overview.md` сделай таблицу: `id`, `name`, назначение, зависимые core-модули.
>
> **Принципы:** никакой новой философии; двигаться итеративно — сначала манифест и core-модули, затем рефакторинг слоёв; сопровождать тестами; устранять дубли без ломки репозитория.
